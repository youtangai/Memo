# 研究テーマ
PC余剰資源を活用するクラウドコンピューティング基盤の実現

# 研究の目的
- 大学の余剰資源を活用したコンテナクラウド環境の構築を目指している
- 余剰資源を活用することで以下の課題が考えられる
  - 本来の用途による余剰資源の圧迫
  - クラウド管理者の意図しないシャットダウンによる余剰資源の消失
- これらの課題への対処方法としてマイグレーションが有効である
  - 余剰資源が圧迫されたら，他の計算ノードへ避難
  - 余剰資源が消失したら，他の計算ノードへ避難
- しかし，余剰資源を活用したコンテナクラウド環境では，頻繁にマイグレーションが発生すると考える
- 従来のコンテナマイグレーション手法では，頻繁なマイグレーションには対応できない
  - マイグレーションの所要時間が長ければ，コンテナにアクセスできない時間も長くなる
- 本研究では頻繁にコンテナマイグレーションが発生するような環境において，コンテナマイグレーションの所要時間を削減することを目的とする

# 従来の研究
## これまでの研究
- Voyager
  - コンテナ内のローカルファイルを，必要になったときにコピーする
  - バックグランドで，ローカルファイルをコピーし続ける
  - 課題
    - 頻繁にコンテナマイグレーションが発生するような環境において，本手法は適応できない
- Redundancy Migration
  - エッジコンピューティング環境に最適なコンテナマイグレーション手法の提案
  - マイグレーションが決定したら，クライアントは遷移先ノードにデータを投げるようになる
  - 遷移先ノードは受け取ったデータのバッファリングと遷移元ノードへの転送を行う
  - 遷移元ノードは，遷移先ノードからデータを受け取ると，遷移元コンテナで受け取ったデータを処理する
  - 遷移元ノードは遷移元コンテナを動かしたまま，チェックポイント(コンテナのメモリマップやファイルディスクリプタの情報を保存したもの)を作成し，遷移先ノードへ転送する
  - 遷移先ノードは，チェックポイントを受け取ると，遷移先コンテナとしてレストアする
  - 遷移先ノードは，バッファリングしていたデータを遷移先コンテナで処理する
  - バッファリングされたデータが無くなった時点で，遷移元コンテナと遷移先コンテナが同じ状態になったとみなし，遷移元ノードへのデータ転送とバッファリングを停止する
  - 課題
    - 頻繁にマイグレーションが発生するような環境では，バッファリングされたデータの処理が終わる前に，再度マイグレーションが発生してしまう可能性がある

## 前年度までの研究
- 2017年度
  - 2017年度は，教室PCの余剰資源を用いてクラウド環境を構築する際に考慮すべき課題の検討と解決を行った．余剰資源を用いる場合，一般的なデータセンターとは異なり，余剰資源の総量が動的に変化すると考える．例えば，本来の用途である授業利用によって余剰計算資源が圧迫され，コンテナの動作が遅くなると考える．また，教室PCは学生であれば誰でも操作可能な状況にあるため，教室PCがシャットダウンされてしまう可能性が存在する．その場合，その教室PC上に展開されていたコンテナへアクセスできなくなってしまう．これらの課題をコンテナマイグレーションで解決した．
  - オープンソースなクラウド基盤であるOpenStackを用いて，PC教室を想定した実験的なコンテナクラウド環境を構築した．
  - OpenStackでは，コンテナマイグレーションがサポートされていなかったので，Optimaという追加コンポーネントを実装することで，OpenStack上でのコンテナマイグレーションを実現した．
  - 実装したOptimaの性能を評価するために，Optimaによるコンテナマイグレーションの所要時間を計測した．その結果，Optimaによるコンテナマイグレーションの所要時間がおよそ32秒であることが分かった．
  - 頻繁にマイグレーションが発生するような環境において，1回のマイグレーションで32秒かかるのは長すぎるため，所要時間を削減する必要があった．
  - そこで，過去のチェックポイントからの変更差分のみを抽出し，チェックポイントのサイズを小さくすることで，その転送時間を削減する手法として残身型マイグレーション手法を考案した．
- 2018年度
  - 2018年度は，残身型マイグレーションの実現手法を検討した．
  - 残身型マイグレーションを実現するためには
    - 差分のみを抽出するために必要
      - コンテナを復元した瞬間からメモリ変更追跡を開始する必要がある
    - 適切な遷移先を決定するスケジューラが必要
      - 適当にやるとマイグレーションが多発する
      - 授業利用の予定がない
      - CPUとメモリの負荷が低い
      - 過去のチェックポイントを持つ
  - 実装
    - CRIUを改造することで，プロセスの復元時にメモリ変更追跡を可能にした
    - runCを改造することで，CRIUが持つプロセスのメモリ変更追跡機能を，コンテナレベルで利用可能にした
  - 評価
    - runCを改造することで実現した，残身型マイグレーションの評価実験を行った
    - 従来のマイグレーション手法よりも6.5%所要時間を削減できた
  - 結果
    - 十分な時間短縮は達成できなかった
    - runCのマイグレーションは動作が不安定(実用的なアプリケーションのマイグレーションが困難)であることが分かった

# 研究計画
- 本年度は，まず，マイグレーションをより高速化するためにCRIUの高速化を行う．次に，runCよりも安定したマイグレーション機能を有するLXDにて，メモリ変更追跡を可能にする．その後，2018年度に未実装だった，適切な遷移先を決定するスケジューラの実装を行う．最後に，残身型マイグレーション機構の優位性を評価するために実験を行う．
  - CRIUのインカーネル化(なぜ？->よりマイグレーションを高速にするため)
    - CRIUはユーザ空間から，Linuxカーネルが管理しているプロセスの情報を取得している．ユーザ空間を経由することで，オーバヘッドが発生している．そこで，CRIUの機能をLinuxカーネルモジュールとして移植することで，カーネル空間からプロセスの情報を取得可能にする．これにより，ユーザ空間を経由するオーバヘッドを削減し，CRIUの高速化を図る．具体的にどのようにモジュール化するかは検討中である．
  - LXDで残身型マイグレーションを実現(なぜ？->runCでは，マイグレーションできるコンテナに制限があったため．LXDは，安定して様々なコンテナのマイグレーションが可能)
    - runCでは，実用的なアプリケーションが内部で動作しているコンテナのマイグレーションが困難であった．そこで，複雑なアプリケーションが動作するコンテナのマイグレーションが可能なLXD上で，メモリ変更追跡を可能にする．
  - 最適な計算ノードを決定するスケジューラの実装(なぜ？->頻繁にマイグレーションが発生するような環境においても，なるべくマイグレーションの発生を抑えるため)
    - 
